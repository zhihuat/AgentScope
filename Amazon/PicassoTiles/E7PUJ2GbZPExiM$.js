window.aui.amd_define("@amzn/flow-metrics-web-lib-latency",function(){"use strict";function h(e,o){return`${e}+${o}`}class M extends Error{constructor(o){super(o),this.name="MetricsRuleError"}}var v=(e=>(e.aboveTheFold="aboveTheFold",e.functional="functional",e.firstContentfulPaint="firstContentfulPaint",e))(v||{}),N=(e=>(e.EXISTS="EXISTS",e.MAX="MAX",e.MIN="MIN",e.SUM="SUM",e.UNKNOWN="UNKNOWN",e))(N||{});const $={aboveTheFold:"af",functional:"fn",firstContentfulPaint:"fcp_ovr"};function x(e,o,i="ERROR",a){let c;o instanceof Error?c=o:c={message:o?String(o):""},c.message.length===0?c.message=e:c.message=`${e} - ${c.message}`;const u={logLevel:i,attribution:"FlowMetricsWebLib",message:""};typeof window<"u"&&window.ueLogError?window.ueLogError(c,u):console.error(`CSM ueLogError not found: ${c} , ${JSON.stringify(u)}`)}const C=(e,o,i)=>{x(e,o,"ERROR")},S=(e,o)=>{typeof window<"u"&&window.uet?window.uet($[e],void 0,void 0,o):console.error("CSM uet not found!")},F=()=>{if(typeof window>"u"){console.error("window is not initialized");return}if(window.ue===void 0){console.error("CSM ue not found");return}if(window.ue.isl){if(window.uex===void 0){console.error("CSM uex not found");return}window.uex("at")}};var p=(e=>(e.NodeEventDataNotFound="M003",e.MetricsCalculatorError="M004",e.MetricInstructionParsingError="M005",e))(p||{});function O(e,o){const i=function(s){const u=h(s.id,s.event);return e.get(u)},a=function(s){const u=(()=>{switch(s.operator){case N.MAX:return Math.max;case N.MIN:return Math.min;case N.SUM:return(l,m)=>l+m;default:throw new M(`Calculation error: Unknown operator : ${s.operator}!`)}})();return s.metricRules.map(l=>{const{combination:m,nodeEvent:g}=l;if(m)return a(m);if(g)return i(g);throw new M(`Calculation error: Unknown rule type : ${Object.keys(l)}!`)}).reduce((l,m)=>u(l,m))};return Object.freeze({calculateMetrics:function(){const s={};try{o.forEach(u=>{const{metricName:l,metricRule:{combination:m,nodeEvent:g}}=u;let b=0;if(m)b=a(m);else if(g)b=i(g);else throw new M(`Calculation error: Unknown rule type : ${Object.keys(u.metricRule)}!`);s[l]=b})}catch(u){C(p.MetricsCalculatorError,u)}return s}})}function k(e){const o=e.split("=");return o.length>=2?o[o.length-1]:null}function y(e){return e.metricName.startsWith("onFlowCardCallback=")?k(e.metricName):null}function R(e,o){return O(e,o).calculateMetrics()}function A(e,o){const i=R(e,o),a=i[v.aboveTheFold],c=i[v.functional],s=i[v.firstContentfulPaint];a&&c?(S(v.aboveTheFold,a),S(v.functional,c)):console.error("sendExperienceRenderMetrics: missing aboveTheFold or functional timestamp!"),s?S(v.firstContentfulPaint,s):console.error("sendExperienceRenderMetrics: using the CSM default fcp!"),F()}function U(e,o){window.P&&window.P.when?window.P.when("A").execute(i=>{const a=i;if(a&&a.trigger){const c=`fm:flowCardCallback+${e}`,s={completionTimestamp:o};a.trigger(c,s),console.log(`Triggered flow card event: ${c}`,s)}else console.error("AUI A object or trigger method not available")}):window.P?window.P.when||console.error("P.when method not available"):console.error("P object not available")}function _(){const e=new Map,o=new Set,i=new Map,a=new Map,c=new Map,s=new Map,u=function(t,r,n){console.log("registerInstrumentationEvents",JSON.stringify({nodeId:t,payload:r,timestamp:n})),n=n||Date.now();for(const[w,f]of Object.entries(r)){const d=h(t,w);if(s.set(d,{lastTimestamp:n,count:f.length,instrumentationEvents:new Set}),f.length===0)console.log("No need to record instrumentation events.",d,n),g(d,n);else for(const E of f)a.set(E,d),m(E)}},l=function(t,r){console.log("recordInstrumentationEvent",JSON.stringify({instrumentationId:t,timestampOverride:r})),c.set(t,r||Date.now()),m(t)},m=function(t){const r=c.get(t),n=a.get(t);if(!r||!n)return;const w=s.get(n);if(!w){C(p.NodeEventDataNotFound);return}const{lastTimestamp:f,count:d,instrumentationEvents:E}=w,I=Math.max(f,r);E.add(t),s.set(n,{lastTimestamp:I,count:d,instrumentationEvents:E}),d===E.size&&(console.log("All instrumentation events recorded",n,I),g(n,I))},g=function(t,r){o.has(t)?i.set(t,r):console.error(`The ${t} is not registered!`);const n=t.split("+")[0],f=k(n)||"flow_experience",d=e.get(f);d&&d.pendingNodeEvents.has(t)&&(d.pendingNodeEvents.delete(t),d.pendingNodeEvents.size===0&&(console.log(`Instruction set nodeEvents for ${f} is complete!`),b(d)))},b=function(t){const r=t.instructions[0],n=r?y(r):null;if(n){console.log(`Processing flow card callback for ${n}`);const f=R(i,[r])[r.metricName];U(n,f),console.log(`Removing flow card instruction set for ${n} from tracking`),e.delete(n)}else console.log("Processing regular metrics for flow_experience"),A(i,t.instructions),console.log("Removing regular metrics instruction set from tracking"),e.delete("flow_experience")},P=function(t,r){if(t.nodeEvent){const n=h(t.nodeEvent.id,t.nodeEvent.event);r.add(n)}else t.combination&&t.combination.metricRules.forEach(n=>{P(n,r)})},D=function(t){console.log("updateMetricInstructions",JSON.stringify(t));const r=new Set;t.forEach(d=>{P(d.metricRule,r)});const n=t[0],f=(n?y(n):null)||"flow_experience";e.set(f,{instructions:t,pendingNodeEvents:r}),console.log(`Created instruction set with key: ${f}`),J(t)},z=function(t,r){o.add(h(t,r))},T=function(t){const{combination:r,nodeEvent:n}=t;if(r)r.metricRules.forEach(w=>{T(w)});else if(n)z(n.id,n.event);else throw new M(`Unknown rule type : ${Object.keys(t)}!`)},J=function(t){try{t.forEach(r=>{T(r.metricRule)})}catch(r){o.clear(),C(p.MetricInstructionParsingError,r)}};return Object.freeze({registerInstrumentationEvents:u,recordInstrumentationEvent:l,updateMetricInstructions:D,flowCardsCallback:function(t,r){console.log("flowCardsCallback",JSON.stringify({slotName:t}));try{if(!window.P){console.error("P object not available");return}window.P.when("A").execute(n=>{const w=n;if(!w){console.error("AUI A object not available");return}const f=`fm:flowCardCallback+${t}`;w.on(f,r),console.log(`Subscribed to flow card event: ${f}`)})}catch(n){console.error("flowCardsCallback: Failed to subscribe to AUI event",n)}},reset:function(){a.clear(),s.clear(),i.clear(),o.clear(),e.clear()},get instrumentation2NodeEvent(){return a},get nodeEventsData(){return s},get nodeEvents(){return i},get registerNodeEvents(){return o}})}const j=_();function L(){var s,u;const e=window==null?void 0:window.fm;if(!e)return;const{flowCardsCallback:o,registerInstrumentationEvents:i,recordInstrumentationEvent:a,updateMetricInstructions:c}=j;e.flowCardsCallback=o,e.registerInstrumentationEvents=i,e.recordInstrumentationEvent=a,e.updateMetricInstructions=c,c(e.i),e._calls&&(e._calls.registerInstrumentationEvents.forEach(l=>i(...l)),e._calls.recordInstrumentationEvent.forEach(l=>a(...l)),(s=e._calls.flowCardsCallback)==null||s.forEach(l=>o(...l)),(u=e._calls.updateMetricInstructions)==null||u.forEach(l=>c(...l))),delete e._calls}L()});
